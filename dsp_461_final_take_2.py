# -*- coding: utf-8 -*-
"""DSP 461 final take 2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DIlWJFd3RS5tG9NI6mJOhRETlxhD-qlB
"""

from google.colab import drive
drive.mount('/content/drive')
# connects to google drive

!pip install gradio scikit-learn pandas matplotlib seaborn --quiet

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.tree import DecisionTreeRegressor, plot_tree
import gradio as gr
from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.linear_model import LinearRegression
#calls the data to bring in
df = pd.read_csv("/content/drive/MyDrive/DSP_461/diabetic_data.csv")
df.head()

df.shape
#shape of the data -> 101766 rows and 50 columns

df.info()
#Info on variable in dataset

missing_counts = df.isna().sum()

print(missing_counts)
#counts the missing variables in dataset ->
#max_glu_serum is missing 96420
#A1Cresult is missing 84748

missing_percentage = df.isna().sum() / len(df) * 100
print(missing_percentage)
# missing in percentage
# max_glu_serum is missing %94.746772
# A1Cresult is missing %83.277322

for column in df:
    print(f"Column: {column}")
    print(df[column].value_counts(normalize=True) * 100)  # multiply by 100 to get %
    print("-" * 50)
#perctenage of each varaible in each column

df_copy = df.copy()
#creating a copy of data

def drop_invalid_genders(df, gender_col='gender'):
    valid_genders = {'Male', 'Female'}
    return df[df[gender_col].isin(valid_genders)].copy()

df = drop_invalid_genders(df)

cols_to_drop = ['weight', 'payer_code', 'medical_specialty','admission_source_id',
                'admission_type_id','patient_nbr','num_lab_procedures','num_procedures',
                'num_medications','number_emergency', 'number_inpatient', 'number_outpatient',
                'max_glu_serum', 'A1Cresult','change',
                "encounter_id","readmitted",
                "metformin", "repaglinide", "nateglinide", "chlorpropamide",
                "glimepiride", "acetohexamide", "glipizide", "glyburide",
                "tolbutamide", "pioglitazone", "rosiglitazone", "acarbose",
                "miglitol", "troglitazone", "tolazamide", "examide",
                "insulin", "glyburide-metformin",
                "glipizide-metformin", "glimepiride-pioglitazone",
                "metformin-rosiglitazone", "metformin-pioglitazone","citoglipton","diabetesMed",]

# Droping selected columns
df_drop = df.drop(columns=[col for col in cols_to_drop if col in df.columns])
df_drop.head()

for column in df_drop:
    print(df_drop[column].value_counts(1))
    print("-" * 50)
#perctenage of each varaible in each column

race_counts = df['race'].value_counts()

# bar graph from each race
plt.figure(figsize=(8, 5))
race_counts.plot(kind='bar', color='lightblue', edgecolor='black')

plt.title('Count of Each Race in Dataset')
plt.xlabel('Race')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

gender_counts = df['gender'].value_counts()

# bar graph for each gender
plt.figure(figsize=(8, 5))
gender_counts.plot(kind='bar', color='lightblue', edgecolor='black')

plt.title('Count of Each Gender in Dataset')
plt.xlabel('Gender')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

time_in_hospital_counts = df['time_in_hospital'].value_counts()

# bar graph to how many times each length of hosptail stay occured
plt.figure(figsize=(8, 5))
time_in_hospital_counts.plot(kind='bar', color='lightblue', edgecolor='black')

plt.title('Count of Each Time in Hospital in Dataset')
plt.xlabel('Time in Hospital')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

age_counts = df['age'].value_counts()

# bar graph for age distrubation in data
plt.figure(figsize=(8, 5))
age_counts.plot(kind='bar', color='lightblue', edgecolor='black')

plt.title('Count of Each Age in Dataset')
plt.xlabel('Age')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

number_diagnoses_counts = df['number_diagnoses'].value_counts()

# bar graph for number of diagnoses distrubation in data
plt.figure(figsize=(8, 5))
number_diagnoses_counts.plot(kind='bar', color='lightblue', edgecolor='black')

plt.title('Count of Each Number of Diagnoses in Dataset')
plt.xlabel('Number of Diagnoses')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

df_copy['admission_type_id'].value_counts()
# 1 = emergency
# 2 = urgent
# 3 = elective
# 4 = newborn
# 5 = not available
# 6 = null
# 7 = trauma center
# 8 = not mapped

def translate_admission_type(admission_id):
    mapping = {
        1: 'Emergency',
        2: 'Urgent',
        3: 'Elective',
        4: 'Newborn',
        5: 'Not Available',
        6: 'Null',
        7: 'Trauma Center',
        8: 'Not Mapped'
    }
    return mapping.get(admission_id, 'Unknown')  # default if ID not in mapping

# Apply it
df_drop['admission_type'] = df_copy['admission_type_id'].apply(translate_admission_type)
df_drop['admission_type'].value_counts()

df_drop['discharge_disposition_id'].value_counts()
# 1 = Discharged to home
# 2 = Discharged/transferred to another short term hospital
# 3 = Discharged/transferred to SNF (Skilled Nursing Facility)
# 4 = Discharged/transferred to ICF (# 4 = Discharged/transferred to)
# 5 = Discharged/transferred to another type of inpatient care institution
# 6 = Discharged/transferred to home with home health service
# 7 = Left AMA
# 8 = Discharged/transferred to home under care of Home IV provider
# 9 = Admitted as an inpatient to this hospital
# 10 = Neonate discharged to another hospital for neonatal aftercare
# 11 = Expired
# 12 = Still patient or expected to return for outpatient services
# 13 = Hospice / home
# 14 = Hospice / medical facility
# 15 = Discharged/transferred within this institution to Medicare approved swing bed
# 16 = Discharged/transferred/referred another institution for outpatient services
# 17 = Discharged/transferred/referred to this institution for outpatient services
# 18 = NULL
# 19 = Expired at home. Medicaid only, hospice.
# 20 = Expired in a medical facility. Medicaid only, hospice.
# 21 = Expired, place unknown. Medicaid only, hospice.
# 22 = Discharged/transferred to another rehab fac including rehab units of a hospital .
# 23 = Discharged/transferred to a long term care hospital.
# 24 = Discharged/transferred to a nursing facility certified under Medicaid but not certified under Medicare.
# 25 = Not Mapped
# 26 = Unknown/Invalid
# 27 = Discharged/transferred to a federal health care facility.
# 28 = Discharged/transferred/referred to a psychiatric hospital of psychiatric distinct part unit of a hospital
# 29 = Discharged/transferred to a Critical Access Hospital (CAH).

def translate_discharge_disposition(code):
    discharge_disposition_map = {
        1: 'Discharged to home',
        2: 'Discharged/transferred to another short term hospital',
        3: 'Discharged/transferred to SNF (Skilled Nursing Facility)',
        4: 'Discharged/transferred to ICF',
        5: 'Discharged/transferred to another type of inpatient care institution',
        6: 'Discharged/transferred to home with home health service',
        7: 'Left AMA (Against Medical Advice)',
        8: 'Discharged/transferred to home under care of Home IV provider',
        9: 'Admitted as an inpatient to this hospital',
        10: 'Neonate discharged to another hospital for neonatal aftercare',
        11: 'Expired',
        12: 'Still patient or expected to return for outpatient services',
        13: 'Hospice / home',
        14: 'Hospice / medical facility',
        15: 'Discharged/transferred within this institution to Medicare approved swing bed',
        16: 'Discharged/transferred/referred to another institution for outpatient services',
        17: 'Discharged/transferred/referred to this institution for outpatient services',
        18: 'NULL',
        19: 'Expired at home (Medicaid only, hospice)',
        20: 'Expired in a medical facility (Medicaid only, hospice)',
        21: 'Expired, place unknown (Medicaid only, hospice)',
        22: 'Discharged/transferred to another rehab facility (including rehab units of a hospital)',
        23: 'Discharged/transferred to a long term care hospital',
        24: 'Discharged/transferred to a Medicaid-certified nursing facility (not certified under Medicare)',
        25: 'Not Mapped',
        26: 'Unknown/Invalid',
        27: 'Discharged/transferred to a federal health care facility',
        28: 'Discharged/transferred/referred to a psychiatric hospital or unit',
        29: 'Discharged/transferred to a Critical Access Hospital (CAH)'
    }
    return discharge_disposition_map.get(code, 'Unknown')

df_drop['discharge_disposition'] = df_drop['discharge_disposition_id'].apply(translate_discharge_disposition)
df_drop['discharge_disposition'].value_counts()

df_copy['admission_source_id'].value_counts()
# 1 = Physician Referral
# 2 = Clinic Referral
# 3 = HMO Referral
# 4 = Transfer from a hospital
# 5 = Transfer from a Skilled Nursing Facility (SNF)
# 6 = Transfer from another health care facility
# 7 = Emergency Room
# 8 = Court/Law Enforcement
# 9 = Not Available
# 10 = Transfer from critial access hospital
# 11 = Normal Delivery
# 12 = Premature Delivery
# 13 = Sick Baby
# 14 = Extramural Birth
# 15 = Not Available
# 17 = NULL
# 18 = Transfer From Another Home Health Agency
# 19 = Readmission to Same Home Health Agency
# 20 = Not Mapped
# 21 = Unknown/Invalid
# 22 = Transfer from hospital inpt/same fac reslt in a sep claim
# 23 = Born inside this hospital
# 24 = Born outside this hospital
# 25 = Transfer from Ambulatory Surgery Center
# 26 = Transfer from Hospice

def translate_admission_source(code):
    admission_source_map = {
        1: 'Physician Referral',
        2: 'Clinic Referral',
        3: 'HMO Referral',
        4: 'Transfer from a hospital',
        5: 'Transfer from a Skilled Nursing Facility (SNF)',
        6: 'Transfer from another health care facility',
        7: 'Emergency Room',
        8: 'Court/Law Enforcement',
        9: 'Not Available',
        10: 'Transfer from Critical Access Hospital',
        11: 'Normal Delivery',
        12: 'Premature Delivery',
        13: 'Sick Baby',
        14: 'Extramural Birth',
        15: 'Not Available',          # duplicate code (kept same meaning)
        17: 'NULL',
        18: 'Transfer From Another Home Health Agency',
        19: 'Readmission to Same Home Health Agency',
        20: 'Not Mapped',
        21: 'Unknown/Invalid',
        22: 'Transfer from hospital inpatient/same facility resulting in separate claim',
        23: 'Born inside this hospital',
        24: 'Born outside this hospital',
        25: 'Transfer from Ambulatory Surgery Center',
        26: 'Transfer from Hospice'
    }
    return admission_source_map.get(code, 'Unknown')
df_copy['admission_source'] = df_copy['admission_source_id'].apply(translate_admission_source)
df_copy['admission_source'].value_counts()

df_drop['diag_1'].value_counts()

df_drop['diag_2'].value_counts()

df_drop['diag_3'].value_counts()

"""Key from the study

1.   Group name	icd9 codes	Number of encounters	% of encounter	Description
2. Circulatory	390â€“459, 785	21,411	30.6%	Diseases of the circulatory system
3. Respiratory	460â€“519, 786	9,490	13.6%	Diseases of the respiratory system
4. Digestive	520â€“579, 787	6,485	9.3%	Diseases of the digestive system
5. Diabetes	250.xx	5,747	8.2%	Diabetes mellitus
6. Injury	800â€“999	4,697	6.7%	Injury and poisoning
7. Musculoskeletal	710â€“739	4,076	5.8%	Diseases of the musculoskeletal system and connective tissue
8. Genitourinary	580â€“629, 788	3,435	4.9%	Diseases of the genitourinary system
9. Neoplasms	140â€“239	2,536	3.6%	Neoplasms
10. Other (17.3%) 780, 781, 784, 790â€“799	2,136	3.1%	Other symptoms, signs, and ill-defined conditions
11. 240â€“279, without 250	1,851	2.6%	Endocrine, nutritional, and metabolic diseases and immunity disorders, without diabetes
12. 680â€“709, 782	1,846	2.6%	Diseases of the skin and subcutaneous tissue
13. 001â€“139	1,683	2.4%	Infectious and parasitic diseases
14. 290â€“319	1,544	2.2%	Mental disorders
15. Eâ€“V	918	1.3%	External causes of injury and supplemental classification
16. 280â€“289	652	0.9%	Diseases of the blood and blood-forming organs
17. 320â€“359	634	0.9%	Diseases of the nervous system
18. 630â€“679	586	0.8%	Complications of pregnancy, childbirth, and the puerperium
19. 360â€“389	216	0.3%	Diseases of the sense organs
20. 740â€“759	41	0.1%	Congenital anomalies



"""

# Define mapping based on ICD-9 ranges
diagnosis_groups = [
    ("Circulatory", [(390, 459), (785, 785)]),
    ("Respiratory", [(460, 519), (786, 786)]),
    ("Digestive", [(520, 579), (787, 787)]),
    ("Diabetes", [(250, 250)]),
    ("Injury", [(800, 999)]),
    ("Musculoskeletal", [(710, 739)]),
    ("Genitourinary", [(580, 629), (788, 788)]),
    ("Neoplasms", [(140, 239)]),
    ("Other", [(780, 780), (781, 781), (784, 784), (790, 799)]),
    ("Endocrine_no_diabetes", [(240, 279)]),
    ("Skin", [(680, 709), (782, 782)]),
    ("Infectious", [(1, 139)]),
    ("Mental", [(290, 319)]),
    ("External", []),  # E and V codes
    ("Blood", [(280, 289)]),
    ("Nervous", [(320, 359)]),
    ("Pregnancy", [(630, 679)]),
    ("Sense_organs", [(360, 389)]),
    ("Congenital", [(740, 759)])
]

def map_icd9_to_group(code):
    if pd.isna(code):
        return np.nan
    code_str = str(code)

    # Handle 'E' or 'V' codes explicitly
    if code_str.startswith(("E", "V")):
        return "External"

    # Convert numeric part safely
    try:
        num = int(code_str.split('.')[0])  # e.g., 250.13 â†’ 250
    except ValueError:
        return "Other"

    # Check each range
    for group, ranges in diagnosis_groups:
        for r in ranges:
            if r[0] <= num <= r[1]:
                return group

    return "Other"  # default if no match

df_drop['dig_group_1'] = df_drop['diag_1'].apply(map_icd9_to_group)
df_drop['dig_group_1'].value_counts(dropna=False)

percentages = df_drop['dig_group_1'].value_counts(normalize=True, dropna=False) * 100

print(percentages)

df_drop['dig_group_2'] = df_drop['diag_2'].apply(map_icd9_to_group)
df_drop['dig_group_2'].value_counts(dropna=False)

percentages = df_drop['dig_group_2'].value_counts(normalize=True, dropna=False) * 100

print(percentages)

df_drop['dig_group_3'] = df_drop['diag_3'].apply(map_icd9_to_group)
df_drop['dig_group_3'].value_counts(dropna=False)

percentages = df_drop['dig_group_3'].value_counts(normalize=True, dropna=False) * 100

print(percentages)

dig_group_1_counts = df_drop['dig_group_1'].value_counts()

# Bar graph of counts of each diagnosis
plt.figure(figsize=(8, 5))
dig_group_1_counts.plot(kind='bar', color='lightblue', edgecolor='black')

plt.title('Count of Each Diagnosis 1 in Dataset')
plt.xlabel('Diagnosis 1')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

dig_group_2_counts = df_drop['dig_group_2'].value_counts()

# Bar graph of counts of each diagnosis
plt.figure(figsize=(8, 5))
dig_group_2_counts.plot(kind='bar', color='lightblue', edgecolor='black')

plt.title('Count of Each Diagnosis 2 in Dataset')
plt.xlabel('Diagnosis 2')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

dig_group_3_counts = df_drop['dig_group_3'].value_counts()

# Bar graph of counts of each diagnosis
plt.figure(figsize=(8, 5))
dig_group_3_counts.plot(kind='bar', color='lightblue', edgecolor='black')

plt.title('Count of Each Diagnosis 3 in Dataset')
plt.xlabel('Diagnosis 3')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

#bar graph time in hosptial vs time
sns.barplot(x='age', y='time_in_hospital', data=df_drop, ci=75)
plt.xticks(rotation=45)
plt.show()

for column in df_drop:
    print(df_drop[column].value_counts(1))
    print("-" * 50)

#creates a new column with binary for 0 lived and 1 died
def add_mortality_column(df):

    death_codes = {11, 19, 20, 21}

    df['mortality'] = df['discharge_disposition_id'].apply(
        lambda x: 'died' if x in death_codes else 'lived'
    )

    return df

df_drop = add_mortality_column(df_drop)
print(df_drop[['discharge_disposition_id', 'mortality']])

#counts the patients who lived and died
print(df_drop['mortality'].value_counts())

for column in df_drop:
    print(df_drop[column].value_counts(1))
    print("-" * 50)

df_drop.drop(['discharge_disposition_id','discharge_disposition','admission_type','diag_1','diag_2','diag_3'], axis=1, inplace=True)

for column in df_drop:
    print(df_drop[column].value_counts(1))
    print("-" * 50)

df_encoded = pd.get_dummies(df_drop, drop_first=False)
df_encoded_copy = df_encoded.copy()
df_encoded_copy_prediction = df_encoded.copy()
df_encoded.info()

for column in df_encoded:
    print(df_encoded[column].value_counts(1))
    print("-" * 50)

X = df_encoded.drop(["time_in_hospital"], axis=1, errors='ignore')

y = df_encoded["time_in_hospital"]
tree_main = DecisionTreeRegressor(max_depth=4, random_state=42)
tree_main.fit(X, y)

importance = (
    pd.DataFrame({
        "Variable": X.columns,
        "Importance": tree_main.feature_importances_
    })
    .sort_values(by="Importance", ascending=False)
)

mae = mean_absolute_error(y, tree_main.predict(X))
mse = mean_squared_error(y, tree_main.predict(X))
rmse = np.sqrt(mse)
r2 = r2_score(y, tree_main.predict(X))
print("\nTop 20 Important Variables:")
print(importance.head(20))


plt.figure(figsize=(18,8))
plot_tree(tree_main, feature_names=X.columns, filled=True, rounded=True, fontsize=8)
plt.title("Decision Tree Regressor (All Variables One-Hot Encoded)")
plt.show()


plt.figure(figsize=(8,6))
sns.barplot(data=importance.head(10), x="Importance", y="Variable", palette="viridis")
plt.title("Top 10 Most Important Features for LOS")
plt.show()

print("Mean Absolute Error (MAE):", mae)
print("Mean Squared Error (MSE):", mse)
print("Root Mean Squared Error (RMSE):", rmse)
print("R-squared (RÂ²):", r2)

df_encoded.info()

age_columns = [
    'age_[0-10)',
    'age_[10-20)',
    'age_[20-30)',
    'age_[30-40)',
    'age_[40-50)',
    'age_[50-60)',
    'age_[60-70)',
    'age_[70-80)',
    'age_[80-90)',
    'age_[90-100)'
]
def get_feature_importance(df, group_name):

    # Drop target only (not age columns!)
    X = df.drop(['time_in_hospital'], axis=1, errors='ignore')
    y = df['time_in_hospital']

    tree = DecisionTreeRegressor(max_depth=4, random_state=42)
    tree.fit(X, y)

    importance = (
        pd.DataFrame({"Variable": X.columns, "Importance": tree.feature_importances_})
        .sort_values(by="Importance", ascending=False)
    )

    # Metrics
    mae = mean_absolute_error(y, tree.predict(X))
    mse = mean_squared_error(y, tree.predict(X))
    rmse = np.sqrt(mse)
    r2 = r2_score(y, tree.predict(X))

    print(f"\nMean Absolute Error (MAE) for {group_name}:", mae)
    print(f"Mean Squared Error (MSE) for {group_name}:", mse)
    print(f"Root Mean Squared Error (RMSE) for {group_name}:", rmse)
    print(f"R-squared (RÂ²) for {group_name}:", r2)

    # Plot tree
    print(f"\nðŸ“Œ Decision Tree for {group_name}")
    plt.figure(figsize=(18, 8))
    plot_tree(tree, feature_names=X.columns, filled=True, rounded=True, fontsize=8)
    plt.title(f"Decision Tree â€” {group_name}", fontsize=16)
    plt.show()

    return importance, tree
importance_age = {}
tree_age = {}

for col in age_columns:
    age_name = col.replace("age_", "").replace("[", "").replace(")", "")  # e.g. "0-10"
    safe_name = age_name.replace("-", "_")  # variable-safe

    print(f"\n=== Processing age group {age_name} ===")

    df_age = df_encoded_copy[df_encoded_copy[col] == True]

    imp, tree_model = get_feature_importance(df_age, age_name)

    importance_age[safe_name] = imp
    tree_age[safe_name] = tree_model

    # create variable dynamically
    globals()[f"tree_age_{safe_name}"] = tree_model
    print(f"Created variable: tree_age_{safe_name}")

for age_key, imp_df in importance_age.items():
  print(f"\n Top 10 Features â€” Age Group {age_key.replace('_','-')}")
  top10 = imp_df.sort_values("Importance", ascending=False).head(10)
  print(top10.to_string(index=False))

# Separate survived and died patients
df_survived = df_encoded[df_encoded['mortality_died'] == False]
df_died = df_encoded[df_encoded['mortality_died'] == True]

X_survived = df_survived.drop(['time_in_hospital', 'mortality_died', 'mortality_lived'], axis=1, errors='ignore')
y_survived = df_survived['time_in_hospital']

X_died = df_died.drop(['time_in_hospital', 'mortality_died', 'mortality_lived'], axis=1, errors='ignore')
y_died = df_died['time_in_hospital']

# Survived
tree_survived = DecisionTreeRegressor(max_depth=4, random_state=42)
tree_survived.fit(X_survived, y_survived)

# Died
tree_died = DecisionTreeRegressor(max_depth=4, random_state=42)
tree_died.fit(X_died, y_died)

mort_model = RandomForestClassifier(n_estimators=100, random_state=42)
mort_model.fit(X_died, y_died)

importance_survived = pd.DataFrame({
    "Variable": X_survived.columns,
    "Importance": tree_survived.feature_importances_
}).sort_values(by="Importance", ascending=False)

importance_died = pd.DataFrame({
    "Variable": X_died.columns,
    "Importance": tree_died.feature_importances_
}).sort_values(by="Importance", ascending=False)

mae_survived = mean_absolute_error(y_survived, tree_survived.predict(X_survived))
mae_died = mean_absolute_error(y_died, tree_died.predict(X_died))

mse_survived = mean_squared_error(y_survived, tree_survived.predict(X_survived))
mse_died = mean_squared_error(y_died, tree_died.predict(X_died))

rmse_survied = np.sqrt(mse_survived)
rmse_died = np.sqrt(mse_died)

r2_survived = r2_score(y_survived, tree_survived.predict(X_survived))
r2_died = r2_score(y_died, tree_died.predict(X_died))

print("Top 10 Important Features for LOS (Survived):")
print(importance_survived.head(10))

print("\nTop 10 Important Features for LOS (Died):")
print(importance_died.head(10))

print("\nMean Absolute Error (MAE) for Survived:")
print(mae_survived)

print("\nMean Absolute Error (MAE) for Died:")
print(mae_died)

print("\nMean Squared Error (MSE) for Survived:")
print(mse_survived)

print("\nMean Squared Error (MSE) for Died:")
print(mse_died)

print("\nRoot Mean Squared Error (RMSE) for Survived:")
print(rmse_survied)

print("\nRoot Mean Squared Error (RMSE) for Died:")
print(rmse_died)

print("\nR-squared (RÂ²) for Survived:")
print(r2_survived)

# Survived
plt.figure(figsize=(18,8))
plot_tree(tree_survived, feature_names=X_survived.columns, filled=True, rounded=True, fontsize=8)
plt.title("Decision Tree Regressor for LOS (Survived)")
plt.show()



# Feature importance plots
plt.figure(figsize=(8,6))
sns.barplot(data=importance_survived.head(10), x="Importance", y="Variable", palette="viridis")
plt.title("Top 10 Features Affecting LOS (Survived)")
plt.show()

# Died
plt.figure(figsize=(18,8))
plot_tree(tree_died, feature_names=X_died.columns, filled=True, rounded=True, fontsize=8)
plt.title("Decision Tree Regressor for LOS (Died)")
plt.show()

plt.figure(figsize=(8,6))
sns.barplot(data=importance_died.head(10), x="Importance", y="Variable", palette="magma")
plt.title("Top 10 Features Affecting LOS (Died)")
plt.show()

diagnosis_effect_by_outcome = (
    df_encoded
    .groupby(['mortality_died', 'number_diagnoses'])['time_in_hospital']
    .mean()
    .reset_index()
    .sort_values(['mortality_died', 'number_diagnoses'])
)

pivot_effect = diagnosis_effect_by_outcome.pivot(
    index='number_diagnoses',
    columns='mortality_died',
    values='time_in_hospital'
)

# Count total patients per diagnosis group
group_counts = df_encoded.groupby('number_diagnoses')['mortality_died'].count()

# Count deaths per diagnosis
death_counts = df_encoded.groupby('number_diagnoses')['mortality_died'].sum()

# Survived = total - died
survive_counts = group_counts - death_counts

# Build percentage table
survival_stats = pd.DataFrame({
    'survived_pct': (survive_counts / group_counts) * 100,
    'died_pct':     (death_counts / group_counts) * 100
})

print("Survival and Mortality Percentages by Diagnosis Count:")
print(survival_stats)

# Plot
plt.figure(figsize=(12, 6))
pivot_effect.plot(kind='bar', figsize=(12, 6))

plt.title("Average Length of Stay by Number of Diagnoses\nSeparated by Survival Outcome")
plt.xlabel("Number of Diagnoses")
plt.ylabel("Average Time in Hospital (days)")
plt.legend(title="Patient Outcome", labels=["Survived", "Died"])
plt.grid(axis='y', linestyle='--', alpha=0.5)

plt.tight_layout()
plt.show()

# Convert boolean â†’ readable labels
df_encoded['outcome'] = df_encoded['mortality_died'].map({False: 'Survived', True: 'Died'})

plt.figure(figsize=(12,6))

sns.barplot(
    data=df_encoded,
    x='time_in_hospital',
    y='number_diagnoses',
    hue='outcome',
    estimator='mean',
    ci=None,
    palette='Set1'
)

plt.title("Average Number of Diagnoses vs Length of Hospital Stay by Outcome")
plt.xlabel("Time in Hospital (days)")
plt.ylabel("Average Number of Diagnoses")
plt.legend(title="Outcome", bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

df_encoded.drop('outcome', axis=1, inplace=True)

# Split by gender (handles 0/1 or True/False)
df_female = df_encoded_copy[df_encoded_copy['gender_Female'] == 1]
df_male   = df_encoded_copy[df_encoded_copy['gender_Male'] == 1]


def get_feature_importance(df, group_name):
    # Ensure we have enough samples
    if df.shape[0] < 50:
        print(f"âš ï¸ Skipping {group_name} â€” too few records ({df.shape[0]})")
        return None, None

    X = df.drop(['time_in_hospital', 'gender_Female', 'gender_Male'],
                axis=1, errors='ignore')
    y = df['time_in_hospital']

    tree = DecisionTreeRegressor(max_depth=4, random_state=42)
    tree.fit(X, y)

    importance = (
        pd.DataFrame({"Variable": X.columns,
                      "Importance": tree.feature_importances_})
        .sort_values(by="Importance", ascending=False)
    )
    mae = mean_absolute_error(y, tree.predict(X))
    mse = mean_squared_error(y, tree.predict(X))
    rmse = np.sqrt(mse)
    r2 = r2_score(y, tree.predict(X))
    print(f"\nMean Absolute Error (MAE) for {group_name}:", mae)
    print(f"Mean Squared Error (MSE) for {group_name}:", mse)
    print(f"Root Mean Squared Error (RMSE) for {group_name}:", rmse)
    print(f"R-squared (RÂ²) for {group_name}:", r2)
    print(f"\nTop 10 Important Features for LOS ({group_name}):")
    print(importance.head(10))

    # Return both importance and model + feature names (for plotting)
    return importance, tree, X.columns.tolist()


# Run for each gender
importance_female, tree_female, cols_female = get_feature_importance(df_female, "Female")
importance_male,   tree_male,   cols_male   = get_feature_importance(df_male, "Male")

plt.figure(figsize=(18,8))
plot_tree(tree_female, feature_names=cols_female,
          filled=True, rounded=True, fontsize=8)
plt.title("Decision Tree Regressor â€” Female")
plt.show()

plt.figure(figsize=(18,8))
plot_tree(tree_male, feature_names=cols_male,
          filled=True, rounded=True, fontsize=8)
plt.title("Decision Tree Regressor â€” Male")
plt.show()

def decode_gender(row):
    if row.get('gender_Male', 0) == 1:
        return 'Male'
    elif row.get('gender_Unknown/Invalid', 0) == 1:
        return 'Unknown/Invalid'
    else:
        return 'Female'

df_encoded['gender'] = df_encoded.apply(decode_gender, axis=1)

plt.figure(figsize=(12,6))

# Bar plot showing average number of diagnoses per length of hospital stay, grouped by gender
sns.barplot(
    data=df_encoded,
    x='time_in_hospital',
    y='number_diagnoses',
    hue='gender',
    estimator='mean',   # computes the average
    ci=None,            # disables confidence interval
    palette='Set2'
)

plt.title("Average Number of Diagnoses vs Length of Hospital Stay by Gender")
plt.xlabel("Time in Hospital (days)")
plt.ylabel("Average Number of Diagnoses")
plt.legend(title="Gender")
plt.tight_layout()
plt.show()

race_columns = [
    'race_AfricanAmerican',
    'race_Asian',
    'race_Caucasian',
    'race_Hispanic',
    'race_Other'
]

def get_feature_importance(df, group_name):
    # âš ï¸ No skipping â€” always train the tree
    X = df.drop(['time_in_hospital'] + race_columns, axis=1, errors='ignore')
    y = df['time_in_hospital']

    tree = DecisionTreeRegressor(max_depth=4, random_state=42)
    tree.fit(X, y)

    importance = (
        pd.DataFrame({"Variable": X.columns, "Importance": tree.feature_importances_})
        .sort_values(by="Importance", ascending=False)
    )
    mae = mean_absolute_error(y, tree.predict(X))
    mse = mean_squared_error(y, tree.predict(X))
    rmse = np.sqrt(mse)
    r2 = r2_score(y, tree.predict(X))
    print(f"\nMean Absolute Error (MAE) for {group_name}:", mae)
    print(f"Mean Squared Error (MSE) for {group_name}:", mse)
    print(f"Root Mean Squared Error (RMSE) for {group_name}:", rmse)
    print(f"R-squared (RÂ²) for {group_name}:", r2)

    # Print the tree
    print(f"\n Decision Tree for {group_name}")
    plt.figure(figsize=(18, 8))
    plot_tree(tree, feature_names=X.columns, filled=True, rounded=True, fontsize=8)
    plt.title(f"Decision Tree â€” {group_name}", fontsize=16)
    plt.show()

    return importance, tree


importance_results = {}
tree_race = {}

for col in race_columns:
    race_name = col.replace("race_", "")     # "Asian"
    safe_name = race_name.replace(" ", "")   # just in case

    print(f"\n=== Processing {safe_name} ===")

    df_race = df_encoded_copy[df_encoded_copy[col] == 1]

    imp, tree_model = get_feature_importance(df_race, safe_name)

    importance_results[safe_name] = imp
    tree_race[safe_name] = tree_model

    # Always create variable
    globals()[f"tree_{safe_name}"] = tree_model
    print(f"Created variable: tree_{safe_name}")

race_columns = [
    'race_AfricanAmerican',
    'race_Asian',
    'race_Caucasian',
    'race_Hispanic',
    'race_Other'
]

def get_feature_importance(df, group_name):
    # Make sure enough data exists
    if df.shape[0] < 50:
        print(f"âš ï¸ Skipping {group_name} â€” too few records ({df.shape[0]})")
        return None, None

    # Split X and y
    X = df.drop(['time_in_hospital'] + race_columns, axis=1, errors='ignore')
    y = df['time_in_hospital']

    # Train tree
    tree = DecisionTreeRegressor(max_depth=4, random_state=42)
    tree.fit(X, y)

    # Feature importance
    importance = (
        pd.DataFrame({"Variable": X.columns, "Importance": tree.feature_importances_})
        .sort_values(by="Importance", ascending=False)
    )

    # Metrics
    preds = tree.predict(X)
    mae = mean_absolute_error(y, preds)
    mse = mean_squared_error(y, preds)
    rmse = np.sqrt(mse)
    r2 = r2_score(y, preds)

    print(f"\nðŸ“Œ Results for {group_name}")
    print("MAE:", mae)
    print("MSE:", mse)
    print("RMSE:", rmse)
    print("RÂ²:", r2)

    # Plot tree
    plt.figure(figsize=(18, 8))
    plot_tree(tree, feature_names=X.columns, filled=True, rounded=True, fontsize=8)
    plt.title(f"Decision Tree â€” {group_name}")
    plt.show()

    return importance, tree


# --- Train a tree per race group ---
importance_results = {}
tree_race = {}     # <--- This dictionary stores models for later

for col in race_columns:
    race_name = col.replace("race_", "")  # e.g., AfricanAmerican
    safe_name = race_name.replace(" ", "")

    print(f"\n=== Processing {safe_name} ===")

    # Filter dataset for specific race
    df_race = df_encoded_copy[df_encoded_copy[col] == 1]

    # Train tree
    imp, model = get_feature_importance(df_race, safe_name)

    # Save in dictionaries
    importance_results[safe_name] = imp
    tree_race[safe_name] = model

    if model is not None:
        print(f"âœ” Saved tree for {safe_name} as tree_race['{safe_name}']")
    else:
        print(f"âš ï¸ Skipped tree creation for {safe_name}")

# Train mortality classifier
mort_model = RandomForestClassifier(n_estimators=100, random_state=42)
mort_model.fit(X.drop(columns=['mortality_died']), df_encoded['mortality_died'])

# Add predicted mortality probability as a feature
mort_prob_train = mort_model.predict_proba(X.drop(columns=['mortality_died']))[:,1]
X['mortality_prob'] = mort_prob_train

# Retrain LOS tree
model = DecisionTreeRegressor(max_depth=4, random_state=42)
model.fit(X, y)

age_columns = [
    'age_[0-10)', 'age_[10-20)', 'age_[20-30)', 'age_[30-40)',
    'age_[40-50)', 'age_[50-60)', 'age_[60-70)', 'age_[70-80)',
    'age_[80-90)', 'age_[90-100)'
]

race_columns = [
    'race_AfricanAmerican', 'race_Asian', 'race_Caucasian',
    'race_Hispanic', 'race_Other'
]
diagnoses_list = [
    "Circulatory","Respiratory","Digestive","Diabetes","Injury",
    "Musculoskeletal","Genitourinary","Neoplasms","Other","Infectious",
    "Endocrine_no_diabetes","Skin","Mental","External","Blood","Nervous",
    "Pregnancy","Sense_organs","Congenital"
]

def predict_length_of_stay(race, gender, age, diag_1_group, diag_2_group, diag_3_group, num_diagnoses):
    """
    Predicts hospital length of stay based on patient characteristics
    """
    try:
        # Create a base row with all False/0 values matching your encoded dataframe structure
        input_data = pd.DataFrame(0, index=[0], columns=df_encoded_copy_prediction.columns)

        # Set the numerical features
        input_data['time_in_hospital'] = 0  # This will be predicted
        input_data['number_diagnoses'] = num_diagnoses

        # Set race (one-hot encoding)
        race_column = f'race_{race}'
        if race_column in input_data.columns:
            input_data[race_column] = 1
        else:
            # Fallback to 'Other' if race not found
            input_data['race_Other'] = 1

        # Set gender (one-hot encoding)
        gender_column = f'gender_{gender}'
        if gender_column in input_data.columns:
            input_data[gender_column] = 1

        # Set age (one-hot encoding)
        age_column = f'age_{age}'
        if age_column in input_data.columns:
            input_data[age_column] = 1

        # Set diagnosis groups (one-hot encoding)
        diag1_column = f'dig_group_1_{diag_1_group}'
        diag2_column = f'dig_group_2_{diag_2_group}'
        diag3_column = f'dig_group_3_{diag_3_group}'

        if diag1_column in input_data.columns:
            input_data[diag1_column] = 1
        if diag2_column in input_data.columns:
            input_data[diag2_column] = 1
        if diag3_column in input_data.columns:
            input_data[diag3_column] = 1

        # Drop target variables from input features
        features = input_data.drop(['time_in_hospital', 'mortality_died', 'mortality_lived'], axis=1)

        # Predict length of stay using your survived model
        length_of_stay_pred = tree_survived.predict(features)[0]

        # Format the output
        if length_of_stay_pred < 1:
            return f"Less than 1 day"
        elif length_of_stay_pred == 1:
            return f"1 day"
        else:
            return f"{length_of_stay_pred:.1f} days"

    except Exception as e:
        return f"Error predicting length of stay: {str(e)}"

#df_encoded_copy_prediction.drop([ 'mortality_lived'], axis=1, inplace=True)

def predict_mortality(race, gender, age, diag_1_group, diag_2_group, diag_3_group, num_diagnoses):
    """
    Predicts mortality probability based on patient characteristics
    """
    try:
        # Create a base row with all False/0 values matching your encoded dataframe structure
        input_data = pd.DataFrame(0, index=[0], columns=df_encoded_copy_prediction.columns)

        # Set the numerical features
        input_data['time_in_hospital'] = 0
        input_data['number_diagnoses'] = num_diagnoses

        # Set race (one-hot encoding)
        race_column = f'race_{race}'
        if race_column in input_data.columns:
            input_data[race_column] = 1
        else:
            # Fallback to 'Other' if race not found
            input_data['race_Other'] = 1

        # Set gender (one-hot encoding)
        gender_column = f'gender_{gender}'
        if gender_column in input_data.columns:
            input_data[gender_column] = 1

        # Set age (one-hot encoding)
        age_column = f'age_{age}'
        if age_column in input_data.columns:
            input_data[age_column] = 1

        # Set diagnosis groups (one-hot encoding)
        diag1_column = f'dig_group_1_{diag_1_group}'
        diag2_column = f'dig_group_2_{diag_2_group}'
        diag3_column = f'dig_group_3_{diag_3_group}'

        if diag1_column in input_data.columns:
            input_data[diag1_column] = 1
        if diag2_column in input_data.columns:
            input_data[diag2_column] = 1
        if diag3_column in input_data.columns:
            input_data[diag3_column] = 1

        # Drop target variables from input features
        features = input_data.drop(['time_in_hospital', 'mortality_died'], axis=1)

        # Predict mortality probability using your mortality model
        mortality_prob = mort_model.predict_proba(features)[0]

        # Determine which class represents "died" (usually class 1)
        # If your model was trained on 'mortality_died' as target, class 1 = died
        mortality_probability = mortality_prob[1]  # Probability of dying

        # Format the output with risk categorization
        risk_level = ""
        if mortality_probability < 0.05:
            risk_level = " (Very Low Risk)"
        elif mortality_probability < 0.1:
            risk_level = " (Low Risk)"
        elif mortality_probability < 0.2:
            risk_level = " (Moderate Risk)"
        elif mortality_probability < 0.4:
            risk_level = " (High Risk)"
        else:
            risk_level = " (Very High Risk)"

        return f"{mortality_probability*100:.2f}%{risk_level}"

    except Exception as e:
        return f"Error predicting mortality: {str(e)}"

# Your complete diagnosis list
diagnoses_list = [
    "Circulatory", "Respiratory", "Digestive", "Diabetes", "Injury",
    "Musculoskeletal", "Genitourinary", "Neoplasms", "Other", "Infectious",
    "Endocrine_no_diabetes", "Skin", "Mental", "External", "Blood", "Nervous",
    "Pregnancy", "Sense_organs", "Congenital"
]

# Create a tabbed interface
with gr.Blocks(title="Hospital Patient Predictions") as demo:
    gr.Markdown("# ðŸ¥ Hospital Patient Outcome Predictions")
    gr.Markdown("Predict patient outcomes based on demographic and diagnostic information")

    with gr.Tab("ðŸ“… Length of Stay Prediction"):
        gr.Markdown("## Predict Hospital Length of Stay")
        gr.Markdown("Estimate how long a patient will remain in the hospital")

        with gr.Row():
            with gr.Column():
                race_input = gr.Dropdown(["AfricanAmerican", "Asian", "Caucasian", "Hispanic", "Other"],
                                       label="Race", value="Caucasian")
                gender_input = gr.Dropdown(["Female", "Male"], label="Gender", value="Female")
                age_input = gr.Dropdown(["[0-10)", "[10-20)", "[20-30)", "[30-40)", "[40-50)",
                                       "[50-60)", "[60-70)", "[70-80)", "[80-90)", "[90-100)"],
                                      label="Age Group", value="[50-60)")

            with gr.Column():
                diag1_input = gr.Dropdown(diagnoses_list,
                                        label="Primary Diagnosis", value="Circulatory")
                diag2_input = gr.Dropdown(diagnoses_list,
                                        label="Secondary Diagnosis", value="Diabetes")
                diag3_input = gr.Dropdown(diagnoses_list,
                                        label="Tertiary Diagnosis", value="Other")
                num_diag_input = gr.Slider(1, 16, value=5, step=1,
                                         label="Number of Diagnoses",
                                         info="Total number of diagnoses recorded (1-16)")

        stay_button = gr.Button("ðŸ”® Predict Length of Stay", variant="primary")
        stay_output = gr.Textbox(label="Predicted Length of Stay", interactive=False)

        stay_button.click(
            fn=predict_length_of_stay,
            inputs=[race_input, gender_input, age_input, diag1_input, diag2_input, diag3_input, num_diag_input],
            outputs=stay_output
        )

    with gr.Tab("âš ï¸ Mortality Risk Prediction"):
        gr.Markdown("## Predict Patient Mortality Risk")
        gr.Markdown("Assess the probability of patient mortality during hospitalization")

        with gr.Row():
            with gr.Column():
                race_input2 = gr.Dropdown(["AfricanAmerican", "Asian", "Caucasian", "Hispanic", "Other"],
                                        label="Race", value="Caucasian")
                gender_input2 = gr.Dropdown(["Female", "Male"], label="Gender", value="Female")
                age_input2 = gr.Dropdown(["[0-10)", "[10-20)", "[20-30)", "[30-40)", "[40-50)",
                                        "[50-60)", "[60-70)", "[70-80)", "[80-90)", "[90-100)"],
                                       label="Age Group", value="[70-80)")

            with gr.Column():
                diag1_input2 = gr.Dropdown(diagnoses_list,
                                         label="Primary Diagnosis", value="Circulatory")
                diag2_input2 = gr.Dropdown(diagnoses_list,
                                         label="Secondary Diagnosis", value="Diabetes")
                diag3_input2 = gr.Dropdown(diagnoses_list,
                                         label="Tertiary Diagnosis", value="Other")
                num_diag_input2 = gr.Slider(1, 16, value=5, step=1,
                                          label="Number of Diagnoses",
                                          info="Total number of diagnoses recorded (1-16)")

        mortality_button = gr.Button("ðŸ”® Predict Mortality Risk", variant="primary")
        mortality_output = gr.Textbox(label="Predicted Mortality Probability", interactive=False)

        mortality_button.click(
            fn=predict_mortality,
            inputs=[race_input2, gender_input2, age_input2, diag1_input2, diag2_input2, diag3_input2, num_diag_input2],
            outputs=mortality_output
        )

    # Optional: Add some examples
    with gr.Tab("ðŸ“‹ Example Cases"):
        gr.Markdown("## Example Patient Cases")
        gr.Markdown("""
        **Example 1 - Low Risk:**
        - Race: Caucasian
        - Gender: Female
        - Age: [50-60)
        - Primary: Diabetes
        - Secondary: Other
        - Tertiary: Other
        - Diagnoses: 3

        **Example 2 - High Risk:**
        - Race: Caucasian
        - Gender: Male
        - Age: [70-80)
        - Primary: Circulatory
        - Secondary: Diabetes
        - Tertiary: Respiratory
        - Diagnoses: 8

        **Example 3 - Young Patient:**
        - Race: AfricanAmerican
        - Gender: Male
        - Age: [20-30)
        - Primary: Injury
        - Secondary: Musculoskeletal
        - Tertiary: Other
        - Diagnoses: 2
        """)

# Launch the interface
demo.launch(share=True)